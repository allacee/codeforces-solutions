/**
source:https://acm.timus.ru/problem.aspx?num=1005
1005. Куча камней.
ПОЯСНЕНИЕ:
Сначала я собирался просто класть следующий наибольший камень в меньшую кучу, но тут же нашлись определенные проблемы. Например, алгоритм давал неправильный ответ на входных данных "5 3 3 2 2 2".
Основная проблема: к моменту, когда мы 'физически' помещаем камень в кучу, мы заранее должны знать в какую именно кучу он должен отправиться.
Основные идеи:
1) Построить дерево всех возможных вариантов
2) Рекурсивно посмотреть все возможные варианты распределения камней
В итоге был реализован 2 вариант:
Сперва мы записываем в массив все значения массы камней, затем пробуем рекурсивно добавлять каждый камень в 1 или 2 кучу.
Когда каждый камень оказыватся в какой-то куче, проверяем разницу сумм, если она меньше минимальной, то перезаписывается.

Второй вариант является более оптимальным со стороны использованной памяти, так как дерево возможных вариантов распределения строится в рантайме и не хранится как таковое

*/
#include <stdio.h>
#include <cstdint>
//size equals n
//rocks[i] equals w_i

using namespace std;

static uint32_t min_diff = 100000;
static uint8_t size;
static uint32_t * rocks;

void find_min_diff( uint32_t sum_heap1 = 0, uint32_t sum_heap2 = 0, uint8_t i = 0 )
{
    if (i != size)
    {
        find_min_diff(sum_heap1 + rocks[i], sum_heap2, i + 1);
        find_min_diff(sum_heap1, sum_heap2 + rocks[i], i + 1);
    }
    else
        min_diff = min_diff < sum_heap1 - sum_heap2 ? min_diff : sum_heap1 - sum_heap2;
}

int main()
{

    scanf("%hhu", &size);
    rocks = new uint32_t[size];
    for (uint8_t i = 0; i < size; i++)
        scanf("%u", &rocks[i]);

    find_min_diff();
    printf("%d\n", min_diff);

    return 0;
}
